{"version":3,"file":"flexsearch.browser.js","sources":["../src/common.js","../src/lang.js","../src/lang/latin/default.js","../src/global.js","../src/async.js","../src/intersect.js","../src/cache.js","../src/preset.js","../src/index.js","../src/document.js"],"sourcesContent":["export function parse_option(value, default_value){\n  return typeof value !== 'undefined' ? value : default_value;\n}\n\n/**\n * @param {!number} count\n * @returns {Array<Object>}\n */\n\nexport function create_object_array(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = create_object();\n  }\n\n  return array;\n}\n\nexport function create_arrays(count){\n  const array = new Array(count);\n\n  for(let i = 0; i < count; i++){\n    array[i] = [];\n  }\n\n  return array;\n}\n\n/**\n * @param {!Object} obj\n * @returns {Array<string>}\n */\n\nexport function get_keys(obj){\n  return Object.keys(obj);\n}\n\nexport function create_object(){\n  return Object.create(null);\n}\n\nexport function concat(arrays){\n  return [].concat.apply([], arrays);\n}\n\nexport function sort_by_length_down(a, b){\n  return b.length - a.length;\n}\n\nexport function is_array(val){\n  return val.constructor === Array;\n}\n\nexport function is_string(val){\n  return typeof val === 'string';\n}\n\nexport function is_object(val){\n  return typeof val === 'object';\n}\n\nexport function is_function(val){\n  return typeof val === 'function';\n}\n","import { create_object, get_keys } from './common.js';\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n * @this IndexInterface\n */\n\nexport function pipeline(str, normalize, split, _collapse){\n  if(str){\n    if(normalize){\n      str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n    }\n\n    if(this.matcher){\n      str = replace(str, this.matcher);\n    }\n\n    if(this.stemmer && (str.length > 1)){\n      str = replace(str, this.stemmer);\n    }\n\n    if(_collapse && (str.length > 1)){\n      str = collapse(str);\n    }\n\n    if(split || (split === '')){\n      const words = str.split(/** @type {string|RegExp} */ (split));\n\n      return this.filter ? filter(words, this.filter) : words;\n    }\n  }\n\n  return str;\n}\n\nexport const regex_whitespace = /[\\p{Z}\\p{S}\\p{P}\\p{C}]+/u;\nconst regex_normalize = /[\\u0300-\\u036f]/g;\n\nexport function normalize(str){\n  if(str.normalize){\n    str = str.normalize('NFD').replace(regex_normalize, '');\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @param {boolean|Array<string|RegExp>=} normalize\n * @param {boolean|string|RegExp=} split\n * @param {boolean=} _collapse\n * @returns {string|Array<string>}\n */\n\n// FlexSearch.prototype.pipeline = function(str, normalize, split, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, /** @type {Array<string|RegExp>} */ (normalize));\n//         }\n//\n//         if(str && this.matcher){\n//\n//             str = replace(str, this.matcher);\n//         }\n//\n//         if(this.stemmer && str.length > 1){\n//\n//             str = replace(str, this.stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split || (split === \"\")){\n//\n//                 const words = str.split(/** @type {string|RegExp} */ (split));\n//\n//                 return this.filter ? filter(words, this.filter) : words;\n//             }\n//         }\n//     }\n//\n//     return str;\n// };\n\n// export function pipeline(str, normalize, matcher, stemmer, split, _filter, _collapse){\n//\n//     if(str){\n//\n//         if(normalize && str){\n//\n//             str = replace(str, normalize);\n//         }\n//\n//         if(matcher && str){\n//\n//             str = replace(str, matcher);\n//         }\n//\n//         if(stemmer && str.length > 1){\n//\n//             str = replace(str, stemmer);\n//         }\n//\n//         if(_collapse && str.length > 1){\n//\n//             str = collapse(str);\n//         }\n//\n//         if(str){\n//\n//             if(split !== false){\n//\n//                 str = str.split(split);\n//\n//                 if(_filter){\n//\n//                     str = filter(str, _filter);\n//                 }\n//             }\n//         }\n//     }\n//\n//     return str;\n// }\n\n\n/**\n * @param {Array<string>} words\n * @returns {Object<string, string>}\n */\n\nexport function init_filter(words){\n  const filter = create_object();\n\n  for(let i = 0, length = words.length; i < length; i++){\n    filter[words[i]] = 1;\n  }\n\n  return filter;\n}\n\n/**\n * @param {!Object<string, string>} obj\n * @param {boolean} is_stemmer\n * @returns {Array}\n */\n\nexport function init_stemmer_or_matcher(obj, is_stemmer){\n  const keys = get_keys(obj);\n  const length = keys.length;\n  const final = [];\n\n  let removal = '', count = 0;\n\n  for(let i = 0, key, tmp; i < length; i++){\n    key = keys[i];\n    tmp = obj[key];\n\n    if(tmp){\n      final[count++] = regex(is_stemmer ? '(?!\\\\b)' + key + '(\\\\b|_)' : key);\n      final[count++] = tmp;\n    }\n    else{\n      removal += (removal ? '|' : '') + key;\n    }\n  }\n\n  if(removal){\n    final[count++] = regex(is_stemmer ? '(?!\\\\b)(' + removal + ')(\\\\b|_)' : '(' + removal + ')');\n    final[count] = '';\n  }\n\n  return final;\n}\n\n\n/**\n * @param {!string} str\n * @param {Array} regexp\n * @returns {string}\n */\n\nexport function replace(str, regexp){\n  for(let i = 0, len = regexp.length; i < len; i += 2){\n    str = str.replace(regexp[i], regexp[i + 1]);\n\n    if(!str){\n      break;\n    }\n  }\n\n  return str;\n}\n\n/**\n * @param {!string} str\n * @returns {RegExp}\n */\n\nexport function regex(str){\n  return new RegExp(str, 'g');\n}\n\n/**\n * Regex: replace(/(?:(\\w)(?:\\1)*)/g, \"$1\")\n * @param {!string} string\n * @returns {string}\n */\n\nexport function collapse(string){\n  let final = '', prev = '';\n\n  for(let i = 0, len = string.length, char; i < len; i++){\n    if((char = string[i]) !== prev){\n      final += (prev = char);\n    }\n  }\n\n  return final;\n}\n\n// TODO using fast-swap\nexport function filter(words, map){\n  const length = words.length;\n  const filtered = [];\n\n  for(let i = 0, count = 0; i < length; i++){\n    const word = words[i];\n\n    if(word && !map[word]){\n      filtered[count++] = word;\n    }\n  }\n\n  return filtered;\n}\n\n// const chars = {a:1, e:1, i:1, o:1, u:1, y:1};\n//\n// function collapse_repeating_chars(string){\n//\n//     let collapsed_string = \"\",\n//         char_prev = \"\",\n//         char_next = \"\";\n//\n//     for(let i = 0; i < string.length; i++){\n//\n//         const char = string[i];\n//\n//         if(char !== char_prev){\n//\n//             if(i && (char === \"h\")){\n//\n//                 if((chars[char_prev] && chars[char_next]) || (char_prev === \" \")){\n//\n//                     collapsed_string += char;\n//                 }\n//             }\n//             else{\n//\n//                 collapsed_string += char;\n//             }\n//         }\n//\n//         char_next = (\n//\n//             (i === (string.length - 1)) ?\n//\n//                 \"\"\n//             :\n//                 string[i + 1]\n//         );\n//\n//         char_prev = char;\n//     }\n//\n//     return collapsed_string;\n// }\n","import { pipeline, normalize, regex_whitespace } from '../../lang.js';\n\nexport const rtl = false;\nexport const tokenize = '';\nexport default {\n  encode: encode,\n  rtl: rtl,\n  tokenize: tokenize\n};\n\n/**\n * @this IndexInterface\n */\n\nexport function encode(str){\n  return pipeline.call(\n\n    this,\n    /* string: */ ('' + str).toLowerCase(),\n    /* normalize: */ false,\n    /* split: */ regex_whitespace,\n    /* collapse: */ false\n  );\n}\n","export const global_lang = {};\nexport const global_charset = {};\n\n/**\n * @param {!string} name\n * @param {Object} charset\n */\n\nexport function registerCharset(name, charset){\n  global_charset[name] = charset;\n}\n\n/**\n * @param {!string} name\n * @param {Object} lang\n */\n\nexport function registerLanguage(name, lang){\n  global_lang[name] = lang;\n}\n","//import { promise as Promise } from \"./polyfill.js\";\nimport { is_function, is_object, is_string } from './common.js';\n\nexport default function(prototype){\n  register(prototype, 'add');\n  register(prototype, 'append');\n  register(prototype, 'search');\n  register(prototype, 'update');\n  register(prototype, 'remove');\n}\n\nfunction register(prototype, key){\n  prototype[key + 'Async'] = function(){\n    /** @type {IndexInterface|DocumentInterface} */\n    const self = this;\n    const args = /*[].slice.call*/(arguments);\n    const arg = args[args.length - 1];\n    let callback;\n\n    if(is_function(arg)){\n      callback = arg;\n      delete args[args.length - 1];\n    }\n\n    const promise = new Promise(function(resolve){\n      setTimeout(function(){\n        self.async = true;\n        const res = self[key].apply(self, args);\n        self.async = false;\n        resolve(res);\n      });\n    });\n\n    if(callback){\n      promise.then(callback);\n      return this;\n    }\n    else{\n      return promise;\n    }\n  };\n}\n","import { create_object, concat } from './common.js';\n\n/**\n * Implementation based on Array.indexOf() provides better performance,\n * but it needs at least one word in the query which is less frequent.\n * Also on large indexes it does not scale well performance-wise.\n * This strategy also lacks of suggestion capabilities (matching & sorting).\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\n// export function intersect(arrays, limit, offset, suggest) {\n//\n//     const length = arrays.length;\n//     let result = [];\n//     let check;\n//\n//     // determine shortest array and collect results\n//     // from the sparse relevance arrays\n//\n//     let smallest_size;\n//     let smallest_arr;\n//     let smallest_index;\n//\n//     for(let x = 0; x < length; x++){\n//\n//         const arr = arrays[x];\n//         const len = arr.length;\n//\n//         let size = 0;\n//\n//         for(let y = 0, tmp; y < len; y++){\n//\n//             tmp = arr[y];\n//\n//             if(tmp){\n//\n//                 size += tmp.length;\n//             }\n//         }\n//\n//         if(!smallest_size || (size < smallest_size)){\n//\n//             smallest_size = size;\n//             smallest_arr = arr;\n//             smallest_index = x;\n//         }\n//     }\n//\n//     smallest_arr = smallest_arr.length === 1 ?\n//\n//         smallest_arr[0]\n//     :\n//         concat(smallest_arr);\n//\n//     if(suggest){\n//\n//         suggest = [smallest_arr];\n//         check = create_object();\n//     }\n//\n//     let size = 0;\n//     let steps = 0;\n//\n//     // process terms in reversed order often results in better performance.\n//     // the outer loop must be the words array, using the\n//     // smallest array here disables the \"fast fail\" optimization.\n//\n//     for(let x = length - 1; x >= 0; x--){\n//\n//         if(x !== smallest_index){\n//\n//             steps++;\n//\n//             const word_arr = arrays[x];\n//             const word_arr_len = word_arr.length;\n//             const new_arr = [];\n//\n//             let count = 0;\n//\n//             for(let z = 0, id; z < smallest_arr.length; z++){\n//\n//                 id = smallest_arr[z];\n//\n//                 let found;\n//\n//                 // process relevance in forward order (direction is\n//                 // important for adding IDs during the last round)\n//\n//                 for(let y = 0; y < word_arr_len; y++){\n//\n//                     const arr = word_arr[y];\n//\n//                     if(arr.length){\n//\n//                         found = arr.indexOf(id) !== -1;\n//\n//                         if(found){\n//\n//                             // check if in last round\n//\n//                             if(steps === length - 1){\n//\n//                                 if(offset){\n//\n//                                     offset--;\n//                                 }\n//                                 else{\n//\n//                                     result[size++] = id;\n//\n//                                     if(size === limit){\n//\n//                                         // fast path \"end reached\"\n//\n//                                         return result;\n//                                     }\n//                                 }\n//\n//                                 if(suggest){\n//\n//                                     check[id] = 1;\n//                                 }\n//                             }\n//\n//                             break;\n//                         }\n//                     }\n//                 }\n//\n//                 if(found){\n//\n//                     new_arr[count++] = id;\n//                 }\n//             }\n//\n//             if(suggest){\n//\n//                 suggest[steps] = new_arr;\n//             }\n//             else if(!count){\n//\n//                 return [];\n//             }\n//\n//             smallest_arr = new_arr;\n//         }\n//     }\n//\n//     if(suggest){\n//\n//         // needs to iterate in reverse direction\n//\n//         for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n//\n//             arr = suggest[x];\n//             len = arr && arr.length;\n//\n//             if(len){\n//\n//                 for(let y = 0, id; y < len; y++){\n//\n//                     id = arr[y];\n//\n//                     if(!check[id]){\n//\n//                         check[id] = 1;\n//\n//                         if(offset){\n//\n//                             offset--;\n//                         }\n//                         else{\n//\n//                             result[size++] = id;\n//\n//                             if(size === limit){\n//\n//                                 // fast path \"end reached\"\n//\n//                                 return result;\n//                             }\n//                         }\n//                     }\n//                 }\n//             }\n//         }\n//     }\n//\n//     return result;\n// }\n\n/**\n * Implementation based on Object[key] provides better suggestions\n * capabilities and has less performance scaling issues on large indexes.\n *\n * @param arrays\n * @param limit\n * @param offset\n * @param {boolean|Array=} suggest\n * @returns {Array}\n */\n\nexport function intersect(arrays, limit, offset, suggest) {\n  const length = arrays.length;\n  let result = [];\n  let check;\n  let check_suggest;\n  let size = 0;\n\n  if(suggest){\n    suggest = [];\n  }\n\n  // process terms in reversed order often has advantage for the fast path \"end reached\".\n  // also a reversed order prioritize the order of words from a query.\n\n  for(let x = length - 1; x >= 0; x--){\n    const word_arr = arrays[x];\n    const word_arr_len = word_arr.length;\n    const check_new = create_object();\n\n    let found = !check;\n\n    // process relevance in forward order (direction is\n    // important for adding IDs during the last round)\n\n    for(let y = 0; y < word_arr_len; y++){\n      const arr = word_arr[y];\n      const arr_len = arr.length;\n\n      if(arr_len){\n        // loop through IDs\n\n        for(let z = 0, check_idx, id; z < arr_len; z++){\n          id = arr[z];\n\n          if(check){\n            if(check[id]){\n              // check if in last round\n\n              if(!x){\n                if(offset){\n                  offset--;\n                }\n                else{\n                  result[size++] = id;\n\n                  if(size === limit){\n                    // fast path \"end reached\"\n\n                    return result;\n                  }\n                }\n              }\n\n              if(x || suggest){\n                check_new[id] = 1;\n              }\n\n              found = true;\n            }\n\n            if(suggest){\n              check_suggest[id] = (check_idx = check_suggest[id]) ? ++check_idx : check_idx = 1;\n\n              // do not adding IDs which are already included in the result (saves one loop)\n              // the first intersection match has the check index 2, so shift by -2\n\n              if(check_idx < length){\n                const tmp = suggest[check_idx - 2] || (suggest[check_idx - 2] = []);\n                tmp[tmp.length] = id;\n              }\n            }\n          }\n          else{\n            // pre-fill in first round\n\n            check_new[id] = 1;\n          }\n        }\n      }\n    }\n\n    if(suggest){\n      // re-use the first pre-filled check for suggestions\n\n      check || (check_suggest = check_new);\n    }\n    else if(!found){\n      return [];\n    }\n\n    check = check_new;\n  }\n\n  if(suggest){\n    // needs to iterate in reverse direction\n\n    for(let x = suggest.length - 1, arr, len; x >= 0; x--){\n      arr = suggest[x];\n      len = arr.length;\n\n      for(let y = 0, id; y < len; y++){\n        id = arr[y];\n\n        if(!check[id]){\n          if(offset){\n            offset--;\n          }\n          else{\n            result[size++] = id;\n\n            if(size === limit){\n              // fast path \"end reached\"\n\n              return result;\n            }\n          }\n\n          check[id] = 1;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * @param mandatory\n * @param arrays\n * @returns {Array}\n */\n\nexport function intersect_union(mandatory, arrays) {\n  const check = create_object();\n  const union = create_object();\n  const result = [];\n\n  for(let x = 0; x < mandatory.length; x++){\n    check[mandatory[x]] = 1;\n  }\n\n  for(let x = 0, arr; x <  arrays.length; x++){\n    arr = arrays[x];\n\n    for(let y = 0, id; y < arr.length; y++){\n      id = arr[y];\n\n      if(check[id]){\n        if(!union[id]){\n          union[id] = 1;\n          result[result.length] = id;\n        }\n      }\n    }\n  }\n\n  return result;\n}","import { create_object, is_object } from './common.js';\n\n/**\n * @param {boolean|number=} limit\n * @constructor\n */\n\nfunction CacheClass(limit){\n  /** @private */\n  this.limit = (limit !== true) && limit;\n\n  /** @private */\n  this.cache = create_object();\n\n  /** @private */\n  this.queue = [];\n\n  //this.clear();\n}\n\nexport default CacheClass;\n\n/**\n * @param {string|Object} query\n * @param {number|Object=} limit\n * @param {Object=} options\n * @this {IndexInterface}\n * @returns {Array<number|string>}\n */\n\nexport function searchCache(query, limit, options){\n  if(is_object(query)){\n    query = query['query'];\n  }\n\n  let cache = this.cache.get(query);\n\n  if(!cache){\n    cache = this.search(query, limit, options);\n    this.cache.set(query, cache);\n  }\n\n  return cache;\n}\n\n// CacheClass.prototype.clear = function(){\n//\n//     /** @private */\n//     this.cache = create_object();\n//\n//     /** @private */\n//     this.queue = [];\n// };\n\nCacheClass.prototype.set = function(key, value){\n  if(!this.cache[key]){\n    // it is just a shame that native function array.shift() performs so bad\n\n    // const length = this.queue.length;\n    //\n    // this.queue[length] = key;\n    //\n    // if(length === this.limit){\n    //\n    //     delete this.cache[this.queue.shift()];\n    // }\n\n    // the same bad performance\n\n    // this.queue.unshift(key);\n    //\n    // if(this.queue.length === this.limit){\n    //\n    //     this.queue.pop();\n    // }\n\n    // fast implementation variant\n\n    // let length = this.queue.length;\n    //\n    // if(length === this.limit){\n    //\n    //     length--;\n    //\n    //     delete this.cache[this.queue[0]];\n    //\n    //     for(let x = 0; x < length; x++){\n    //\n    //         this.queue[x] = this.queue[x + 1];\n    //     }\n    // }\n    //\n    // this.queue[length] = key;\n\n    // current fastest implementation variant\n    // theoretically that should not perform better compared to the example above\n\n    let length = this.queue.length;\n\n    if(length === this.limit){\n      delete this.cache[this.queue[length - 1]];\n    }\n    else{\n      length++;\n    }\n\n    for(let x = length - 1; x > 0; x--){\n      this.queue[x] = this.queue[x - 1];\n    }\n\n    this.queue[0] = key;\n  }\n\n  this.cache[key] = value;\n};\n\nCacheClass.prototype.get = function(key){\n  const cache = this.cache[key];\n\n  if(this.limit && cache){\n    // probably the indexOf() method performs faster when matched content is on front (left-to-right)\n    // using lastIndexOf() does not help, it performs almost slower\n\n    const pos = this.queue.indexOf(key);\n\n    // if(pos < this.queue.length - 1){\n    //\n    //     const tmp = this.queue[pos];\n    //     this.queue[pos] = this.queue[pos + 1];\n    //     this.queue[pos + 1] = tmp;\n    // }\n\n    if(pos){\n      const tmp = this.queue[pos - 1];\n      this.queue[pos - 1] = this.queue[pos];\n      this.queue[pos] = tmp;\n    }\n  }\n\n  return cache;\n};\n\nCacheClass.prototype.del = function(id){\n  for(let i = 0, item, key; i < this.queue.length; i++){\n    key = this.queue[i];\n    item = this.cache[key];\n\n    if(item.indexOf(id) !== -1){\n      this.queue.splice(i--, 1);\n      delete this.cache[key];\n    }\n  }\n};\n","import { is_string } from './common.js';\n\n/**\n * @enum {Object}\n * @const\n */\n\nconst preset = {\n\n  'memory': {\n    charset: 'latin:extra',\n    //tokenize: \"strict\",\n    resolution: 3,\n    //threshold: 0,\n    minlength: 4,\n    fastupdate: false\n  },\n\n  'performance': {\n    //charset: \"latin\",\n    //tokenize: \"strict\",\n    resolution: 3,\n    minlength: 3,\n    //fastupdate: true,\n    optimize: false,\n    //fastupdate: true,\n    context: {\n      depth: 2,\n      resolution: 1\n      //bidirectional: false\n    }\n  },\n\n  'match': {\n    charset: 'latin:extra',\n    tokenize: 'reverse',\n    //resolution: 9,\n    //threshold: 0\n  },\n\n  'score': {\n    charset: 'latin:advanced',\n    //tokenize: \"strict\",\n    resolution: 20,\n    minlength: 3,\n    context: {\n      depth: 3,\n      resolution: 9,\n      //bidirectional: true\n    }\n  },\n\n  'default': {\n    // charset: \"latin:default\",\n    // tokenize: \"strict\",\n    // resolution: 3,\n    // threshold: 0,\n    // depth: 3\n  },\n\n  // \"fast\": {\n  //     //charset: \"latin\",\n  //     //tokenize: \"strict\",\n  //     threshold: 8,\n  //     resolution: 9,\n  //     depth: 1\n  // }\n};\n\nexport default function apply_preset(options){\n  if(is_string(options)){\n    if(!preset[options]){\n      console.warn('Preset not found: ' + options);\n    }\n\n    options = preset[options];\n  }\n  else{\n    const preset = options['preset'];\n\n    if(preset){\n      if(!preset[preset]){\n        console.warn('Preset not found: ' + preset);\n      }\n\n      options = Object.assign({}, preset[preset], /** @type {Object} */ (options));\n    }\n  }\n\n  return options;\n}\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { encode as default_encoder } from './lang/latin/default.js';\nimport { create_object, create_object_array, concat, sort_by_length_down, is_array, is_string, is_object, parse_option } from './common.js';\nimport { init_stemmer_or_matcher, init_filter } from './lang.js';\nimport { global_lang, global_charset } from './global.js';\nimport apply_async from './async.js';\nimport { intersect } from './intersect.js';\nimport Cache, { searchCache } from './cache.js';\nimport apply_preset from './preset.js';\n\n/**\n * @constructor\n * @param {Object=} options\n * @param {Object=} _register\n * @return {Index}\n */\n\nexport class Index {\n  constructor(options, _register) {\n    if (!(this instanceof Index)) {\n      return new Index(options);\n    }\n\n    let charset, lang, tmp;\n\n    if (options) {\n      options = apply_preset(options);\n\n      charset = options['charset'];\n      lang = options['lang'];\n\n      if (is_string(charset)) {\n        if (charset.indexOf(':') === -1) {\n          charset += ':default';\n        }\n\n        charset = global_charset[charset];\n      }\n\n      if (is_string(lang)) {\n        lang = global_lang[lang];\n      }\n    }\n    else {\n      options = {};\n    }\n\n    let resolution, optimize, context = options['context'] || {};\n\n    this.encode = options['encode'] || (charset && charset.encode) || default_encoder;\n    this.register = _register || create_object();\n    this.resolution = resolution = options['resolution'] || 9;\n    this.tokenize = tmp = (charset && charset.tokenize) || options['tokenize'] || 'strict';\n    this.depth = (tmp === 'strict') && context['depth'];\n    this.bidirectional = parse_option(context['bidirectional'], true);\n    this.optimize = optimize = parse_option(options['optimize'], true);\n    this.fastupdate = parse_option(options['fastupdate'], true);\n    this.minlength = options['minlength'] || 1;\n    this.boost = options['boost'];\n\n    // when not using the memory strategy the score array should not pre-allocated to its full length\n    this.map = optimize ? create_object_array(resolution) : create_object();\n    this.resolution_ctx = resolution = context['resolution'] || 1;\n    this.ctx = optimize ? create_object_array(resolution) : create_object();\n    this.rtl = (charset && charset.rtl) || options['rtl'];\n    this.matcher = (tmp = options['matcher'] || (lang && lang.matcher)) && init_stemmer_or_matcher(tmp, false);\n    this.stemmer = (tmp = options['stemmer'] || (lang && lang.stemmer)) && init_stemmer_or_matcher(tmp, true);\n    this.filter = (tmp = options['filter'] || (lang && lang.filter)) && init_filter(tmp);\n\n    this.cache = (tmp = options['cache']) && new Cache(tmp);\n  }\n  //Index.prototype.pipeline = pipeline;\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   */\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  /**\n   * @param {!number|string} id\n   * @param {!string} content\n   * @param {boolean=} _append\n   * @param {boolean=} _skip_update\n   */\n  add(id, content, _append, _skip_update) {\n    if (content && (id || (id === 0))) {\n      if (!_skip_update && !_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      content = this.encode(content);\n      const length = content.length;\n\n      if (length) {\n        // check context dupes to skip all contextual redundancy along a document\n        const dupes_ctx = create_object();\n        const dupes = create_object();\n        const depth = this.depth;\n        const resolution = this.resolution;\n\n        for (let i = 0; i < length; i++) {\n          let term = content[this.rtl ? length - 1 - i : i];\n          let term_length = term.length;\n\n          // skip dupes will break the context chain\n          if (term && (term_length >= this.minlength) && (depth || !dupes[term])) {\n            let score = get_score(resolution, length, i);\n            let token = '';\n\n            switch (this.tokenize) {\n            case 'full':\n\n              if (term_length > 3) {\n                for (let x = 0; x < term_length; x++) {\n                  for (let y = term_length; y > x; y--) {\n                    if ((y - x) >= this.minlength) {\n                      const partial_score = get_score(resolution, length, i, term_length, x);\n                      token = term.substring(x, y);\n                      this.push_index(dupes, token, partial_score, id, _append);\n                    }\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when term length < 4\n            case 'reverse':\n\n              // skip last round (this token exist already in \"forward\")\n              if (term_length > 2) {\n                for (let x = term_length - 1; x > 0; x--) {\n                  token = term[x] + token;\n\n                  if (token.length >= this.minlength) {\n                    const partial_score = get_score(resolution, length, i, term_length, x);\n                    this.push_index(dupes, token, partial_score, id, _append);\n                  }\n                }\n\n                token = '';\n              }\n\n              // fallthrough to next case to apply forward also\n            case 'forward':\n\n              if (term_length > 1) {\n                for (let x = 0; x < term_length; x++) {\n                  token += term[x];\n\n                  if (token.length >= this.minlength) {\n                    this.push_index(dupes, token, score, id, _append);\n                  }\n                }\n\n                break;\n              }\n\n              // fallthrough to next case when token has a length of 1\n            default:\n              // case \"strict\":\n              if (this.boost) {\n                score = Math.min((score / this.boost(content, term, i)) | 0, resolution - 1);\n              }\n\n              this.push_index(dupes, term, score, id, _append);\n\n              // context is just supported by tokenizer \"strict\"\n              if (depth) {\n                if ((length > 1) && (i < (length - 1))) {\n                  // check inner dupes to skip repeating words in the current context\n                  const dupes_inner = create_object();\n                  const resolution = this.resolution_ctx;\n                  const keyword = term;\n                  const size = Math.min(depth + 1, length - i);\n\n                  dupes_inner[keyword] = 1;\n\n                  for (let x = 1; x < size; x++) {\n                    term = content[this.rtl ? length - 1 - i - x : i + x];\n\n                    if (term && (term.length >= this.minlength) && !dupes_inner[term]) {\n                      dupes_inner[term] = 1;\n\n                      const context_score = get_score(resolution + ((length / 2) > resolution ? 0 : 1), length, i, size - 1, x - 1);\n                      const swap = this.bidirectional && (term > keyword);\n                      this.push_index(dupes_ctx, swap ? keyword : term, context_score, id, _append, swap ? term : keyword);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        this.fastupdate || (this.register[id] = 1);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * @param dupes\n   * @param value\n   * @param score\n   * @param id\n   * @param {boolean=} append\n   * @param {string=} keyword\n   */\n  push_index(dupes, value, score, id, append, keyword) {\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!dupes[value] || (keyword && !dupes[value][keyword])) {\n      if (this.optimize) {\n        arr = arr[score];\n      }\n\n      if (keyword) {\n        dupes = dupes[value] || (dupes[value] = create_object());\n        dupes[keyword] = 1;\n\n        arr = arr[keyword] || (arr[keyword] = create_object());\n      }\n      else {\n        dupes[value] = 1;\n      }\n\n      arr = arr[value] || (arr[value] = []);\n\n      if (!this.optimize) {\n        arr = arr[score] || (arr[score] = []);\n      }\n\n      if (!append || (arr.indexOf(id) === -1)) {\n        arr[arr.length] = id;\n\n        // add a reference to the register for fast updates\n        if (this.fastupdate) {\n          const tmp = this.register[id] || (this.register[id] = []);\n          tmp[tmp.length] = arr;\n        }\n      }\n    }\n  }\n  /**\n   * @param {string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @returns {Array<number|string>}\n   */\n  search(query, limit, options) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options['query'];\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n      }\n    }\n\n    let result = [];\n    let length;\n    let context, suggest, offset = 0;\n\n    if (options) {\n      limit = options['limit'];\n      offset = options['offset'] || 0;\n      context = options['context'];\n      suggest = options['suggest'];\n    }\n\n    if (query) {\n      query = /** @type {Array} */ (this.encode(query));\n      length = query.length;\n\n      // TODO: solve this in one single loop below\n      if (length > 1) {\n        const dupes = create_object();\n        const query_new = [];\n\n        for (let i = 0, count = 0, term; i < length; i++) {\n          term = query[i];\n\n          if (term && (term.length >= this.minlength) && !dupes[term]) {\n            // this fast path just could applied when not in memory-optimized mode\n            if (!this.optimize && !suggest && !this.map[term]) {\n              // fast path \"not found\"\n              return result;\n            }\n            else {\n              query_new[count++] = term;\n              dupes[term] = 1;\n            }\n          }\n        }\n\n        query = query_new;\n        length = query.length;\n      }\n    }\n\n    if (!length) {\n      return result;\n    }\n\n    limit || (limit = 100);\n\n    let depth = this.depth && (length > 1) && (context !== false);\n    let index = 0, keyword;\n\n    if (depth) {\n      keyword = query[0];\n      index = 1;\n    }\n    else {\n      if (length > 1) {\n        query.sort(sort_by_length_down);\n      }\n    }\n\n    for (let arr, term; index < length; index++) {\n      term = query[index];\n\n      // console.log(keyword);\n      // console.log(term);\n      // console.log(\"\");\n      if (depth) {\n        arr = this.add_result(result, suggest, limit, offset, length === 2, term, keyword);\n\n        // console.log(arr);\n        // console.log(result);\n        // when suggestion enabled just forward keyword if term was found\n        // as long as the result is empty forward the pointer also\n        if (!suggest || (arr !== false) || !result.length) {\n          keyword = term;\n        }\n      }\n      else {\n        arr = this.add_result(result, suggest, limit, offset, length === 1, term);\n      }\n\n      if (arr) {\n        return /** @type {Array<number|string>} */ (arr);\n      }\n\n      // apply suggestions on last loop or fallback\n      if (suggest && (index === length - 1)) {\n        let length = result.length;\n\n        if (!length) {\n          if (depth) {\n            // fallback to non-contextual search when no result was found\n            depth = 0;\n            index = -1;\n\n            continue;\n          }\n\n          return result;\n        }\n        else if (length === 1) {\n          // fast path optimization\n          return single_result(result[0], limit, offset);\n        }\n      }\n    }\n\n    return intersect(result, limit, offset, suggest);\n  }\n  /**\n   * Returns an array when the result is done (to stop the process immediately),\n   * returns false when suggestions is enabled and no result was found,\n   * or returns nothing when a set was pushed successfully to the results\n   *\n   * @private\n   * @param {Array} result\n   * @param {Array} suggest\n   * @param {number} limit\n   * @param {number} offset\n   * @param {boolean} single_term\n   * @param {string} term\n   * @param {string=} keyword\n   * @return {Array<Array<string|number>>|boolean|undefined}\n   */\n  add_result(result, suggest, limit, offset, single_term, term, keyword) {\n    let word_arr = [];\n    let arr = keyword ? this.ctx : this.map;\n\n    if (!this.optimize) {\n      arr = get_array(arr, term, keyword, this.bidirectional);\n    }\n\n    if (arr) {\n      let count = 0;\n      const arr_len = Math.min(arr.length, keyword ? this.resolution_ctx : this.resolution);\n\n      // relevance:\n      for (let x = 0, size = 0, tmp, len; x < arr_len; x++) {\n        tmp = arr[x];\n\n        if (tmp) {\n          if (this.optimize) {\n            tmp = get_array(tmp, term, keyword, this.bidirectional);\n          }\n\n          if (offset) {\n            if (tmp && single_term) {\n              len = tmp.length;\n\n              if (len <= offset) {\n                offset -= len;\n                tmp = null;\n              }\n              else {\n                tmp = tmp.slice(offset);\n                offset = 0;\n              }\n            }\n          }\n\n          if (tmp) {\n            // keep score (sparse array):\n            //word_arr[x] = tmp;\n            // simplified score order:\n            word_arr[count++] = tmp;\n\n            if (single_term) {\n              size += tmp.length;\n\n              if (size >= limit) {\n                // fast path optimization\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (count) {\n        if (single_term) {\n          // fast path optimization\n          // offset was already applied at this point\n          return single_result(word_arr, limit, 0);\n        }\n\n        result[result.length] = word_arr;\n        return;\n      }\n    }\n\n    // return an empty array will stop the loop,\n    // to prevent stop when using suggestions return a false value\n    return !suggest && word_arr;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  /**\n   * @param {boolean=} _skip_deletion\n   */\n  remove(id, _skip_deletion) {\n    const refs = this.register[id];\n\n    if (refs) {\n      if (this.fastupdate) {\n        // fast updates performs really fast but did not fully cleanup the key entries\n        for (let i = 0, tmp; i < refs.length; i++) {\n          tmp = refs[i];\n          tmp.splice(tmp.indexOf(id), 1);\n        }\n      }\n      else {\n        remove_index(this.map, id, this.resolution, this.optimize);\n\n        if (this.depth) {\n          remove_index(this.ctx, id, this.resolution_ctx, this.optimize);\n        }\n      }\n\n      _skip_deletion || delete this.register[id];\n\n      if (this.cache) {\n        this.cache.del(id);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Convert `this` into an exportable object\n   */\n  serialize() {\n    return {\n      reg: this.register, // No support for fastupdate\n      opt: this.optimize,\n      map: this.map,\n      ctx: this.ctx\n    };\n  }\n\n  /**\n   * Given a string load an Index object from it\n   * @param {string} str the serialized Index object\n   */\n  static deserialize(obj, params) {\n    // TODO add extra parameter for index initialization?\n    const result = new Index(params);\n    result.optimize = obj.opt;\n    result.register = obj.reg;\n    result.map      = obj.map;\n    result.ctx      = obj.ctx;\n    return result;\n  }\n}\n\n\n\n/**\n * @param {number} resolution\n * @param {number} length\n * @param {number} i\n * @param {number=} term_length\n * @param {number=} x\n * @returns {number}\n */\n\nfunction get_score(resolution, length, i, term_length, x){\n  // console.log(\"resolution\", resolution);\n  // console.log(\"length\", length);\n  // console.log(\"term_length\", term_length);\n  // console.log(\"i\", i);\n  // console.log(\"x\", x);\n  // console.log((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1);\n\n  // the first resolution slot is reserved for the best match,\n  // when a query matches the first word(s).\n\n  // also to stretch score to the whole range of resolution, the\n  // calculation is shift by one and cut the floating point.\n  // this needs the resolution \"1\" to be handled additionally.\n\n  // do not stretch the resolution more than the term length will\n  // improve performance and memory, also it improves scoring in\n  // most cases between a short document and a long document\n\n  return i && (resolution > 1) ? (\n\n    (length + (term_length || 0)) <= resolution ?\n\n      i + (x || 0)\n      :\n      ((resolution - 1) / (length + (term_length || 0)) * (i + (x || 0)) + 1) | 0\n  ):\n    0;\n}\n\n\n\n\nfunction single_result(result, limit, offset){\n  if(result.length === 1){\n    result = result[0];\n  }\n  else{\n    result = concat(result);\n  }\n\n  return offset || (result.length > limit) ?\n\n    result.slice(offset, offset + limit)\n    :\n    result;\n}\n\nfunction get_array(arr, term, keyword, bidirectional){\n  if(keyword){\n    // the frequency of the starting letter is slightly less\n    // on the last half of the alphabet (m-z) in almost every latin language,\n    // so we sort downwards (https://en.wikipedia.org/wiki/Letter_frequency)\n\n    const swap = bidirectional && (term > keyword);\n\n    arr = arr[swap ? term : keyword];\n    arr = arr && arr[swap ? keyword : term];\n  }\n  else{\n    arr = arr[term];\n  }\n\n  return arr;\n}\n\n\n\n\n/**\n * @param map\n * @param id\n * @param res\n * @param optimize\n * @param {number=} resolution\n * @return {number}\n */\n\nfunction remove_index(map, id, res, optimize, resolution){\n  let count = 0;\n\n  if(is_array(map)){\n    // the first array is the score array in both strategies\n\n    if(!resolution){\n      resolution = Math.min(map.length, res);\n\n      for(let x = 0, arr; x < resolution; x++){\n        arr = map[x];\n\n        if(arr){\n          count = remove_index(arr, id, res, optimize, resolution);\n\n          if(!optimize && !count){\n            // when not memory optimized the score index should removed\n\n            delete map[x];\n          }\n        }\n      }\n    }\n    else{\n      const pos = map.indexOf(id);\n\n      if(pos !== -1){\n        // fast path, when length is 1 or lower then the whole field gets deleted\n\n        if(map.length > 1){\n          map.splice(pos, 1);\n          count++;\n        }\n      }\n      else{\n        count++;\n      }\n    }\n  }\n  else{\n    for(let key in map){\n      count = remove_index(map[key], id, res, optimize, resolution);\n\n      if(!count){\n        delete map[key];\n      }\n    }\n  }\n\n  return count;\n}\n\n// TODO bring all these functions into this file\nIndex.prototype.searchCache = searchCache;\napply_async(Index.prototype);\n","/**!\n * FlexSearch.js\n * Copyright 2018-2021 Nextapps GmbH\n * Author: Thomas Wilkerling\n * Licence: Apache-2.0\n * https://github.com/nextapps-de/flexsearch\n */\n\nimport { Index } from './index.js';\nimport Cache, { searchCache } from './cache.js';\nimport { create_object, is_array, is_string, is_object, parse_option } from './common.js';\nimport apply_async from './async.js';\nimport { intersect, intersect_union } from './intersect.js';\n\n/**\n * @constructor\n * @implements DocumentInterface\n * @param {Object=} options\n * @return {Document}\n */\n\nexport class Document {\n  constructor(options) {\n    const document = options['document'] || options['doc'] || options;\n    let opt;\n\n    this.tree = [];\n    this.field = [];\n    this.marker = [];\n    this.register = create_object();\n    this.key = ((opt = document['key'] || document['id']) && parse_tree(opt, this.marker)) || 'id';\n    this.fastupdate = parse_option(options['fastupdate'], true);\n\n    this.storetree = (opt = document['store']) && (opt !== true) && [];\n    this.store = opt && create_object();\n\n    this.tag = ((opt = document['tag']) && parse_tree(opt, this.marker));\n    this.tagindex = opt && create_object();\n\n    this.cache = (opt = options['cache']) && new Cache(opt);\n\n    // do not apply cache again for the indexes\n    options['cache'] = false;\n\n    this.worker = options['worker'];\n\n    // this switch is used by recall of promise callbacks\n    this.async = false;\n\n    this.index = this.parse_descriptor(options, document);\n  }\n\n  /**\n   *\n   * @param id\n   * @param content\n   * @param {boolean=} _append\n   * @returns {Document|Promise}\n   */\n  add(id, content, _append) {\n    if (is_object(id)) {\n      content = id;\n      id = parse_simple(content, this.key);\n    }\n\n    if (content && (id || (id === 0))) {\n      if (!_append && this.register[id]) {\n        return this.update(id, content);\n      }\n\n      for (let i = 0, tree, field; i < this.field.length; i++) {\n        field = this.field[i];\n        tree = this.tree[i];\n\n        if (is_string(tree)) {\n          tree = [tree];\n        }\n\n        add_index(content, tree, this.marker, 0, this.index[field], id, tree[0], _append);\n      }\n\n      if (this.tag) {\n        let tag = parse_simple(content, this.tag);\n        let dupes = create_object();\n\n        if (is_string(tag)) {\n          tag = [tag];\n        }\n\n        for (let i = 0, key, arr; i < tag.length; i++) {\n          key = tag[i];\n\n          if (!dupes[key]) {\n            dupes[key] = 1;\n            arr = this.tagindex[key] || (this.tagindex[key] = []);\n\n            if (!_append || (arr.indexOf(id) === -1)) {\n              arr[arr.length] = id;\n\n              // add a reference to the register for fast updates\n              if (this.fastupdate) {\n                const tmp = this.register[id] || (this.register[id] = []);\n                tmp[tmp.length] = arr;\n              }\n            }\n          }\n        }\n      }\n\n      // TODO: how to handle store when appending contents?\n      if (this.store && (!_append || !this.store[id])) {\n        let store;\n\n        if (this.storetree) {\n          store = create_object();\n\n          for (let i = 0, tree; i < this.storetree.length; i++) {\n            tree = this.storetree[i];\n\n            if (is_string(tree)) {\n              store[tree] = content[tree];\n            }\n            else {\n              store_value(content, store, tree, 0, tree[0]);\n            }\n          }\n        }\n\n        this.store[id] = store || content;\n      }\n    }\n\n    return this;\n  }\n  append(id, content) {\n    return this.add(id, content, true);\n  }\n  update(id, content) {\n    return this.remove(id).add(id, content);\n  }\n  remove(id) {\n    if (is_object(id)) {\n      id = parse_simple(id, this.key);\n    }\n\n    if (this.register[id]) {\n      for (let i = 0; i < this.field.length; i++) {\n        // workers does not share the register\n        this.index[this.field[i]].remove(id, !this.worker);\n\n        if (this.fastupdate) {\n          // when fastupdate was enabled all ids are removed\n          break;\n        }\n      }\n\n      if (this.tag) {\n        // when fastupdate was enabled all ids are already removed\n        if (!this.fastupdate) {\n          for (let key in this.tagindex) {\n            const tag = this.tagindex[key];\n            const pos = tag.indexOf(id);\n\n            if (pos !== -1) {\n              if (tag.length > 1) {\n                tag.splice(pos, 1);\n              }\n              else {\n                delete this.tagindex[key];\n              }\n            }\n          }\n        }\n      }\n\n      if (this.store) {\n        delete this.store[id];\n      }\n\n      delete this.register[id];\n    }\n\n    return this;\n  }\n  /**\n   * @param {!string|Object} query\n   * @param {number|Object=} limit\n   * @param {Object=} options\n   * @param {Array<Array>=} _resolve For internal use only.\n   * @returns {Promise|Array}\n   */\n  search(query, limit, options, _resolve) {\n    if (!options) {\n      if (!limit && is_object(query)) {\n        options = /** @type {Object} */ (query);\n        query = options['query'];\n      }\n      else if (is_object(limit)) {\n        options = /** @type {Object} */ (limit);\n        limit = 0;\n      }\n    }\n\n    let result = [], result_field = [];\n    let pluck, enrich;\n    let field, tag, bool, offset, count = 0;\n\n    if (options) {\n      if (is_array(options)) {\n        field = options;\n        options = null;\n      }\n      else {\n        pluck = options['pluck'];\n        field = pluck || options['index'] || options['field'] /*|| (is_string(options) && [options])*/;\n        tag = options['tag'];\n        enrich = this.store && options['enrich'];\n        bool = options['bool'] === 'and';\n        limit = options['limit'] || 100;\n        offset = options['offset'] || 0;\n\n        if (tag) {\n          if (is_string(tag)) {\n            tag = [tag];\n          }\n\n          // when tags is used and no query was set,\n          // then just return the tag indexes\n          if (!query) {\n            for (let i = 0, res; i < tag.length; i++) {\n              res = get_tag.call(this, tag[i], limit, offset, enrich);\n\n              if (res) {\n                result[result.length] = res;\n                count++;\n              }\n            }\n\n            return count ? result : [];\n          }\n        }\n\n        if (is_string(field)) {\n          field = [field];\n        }\n      }\n    }\n\n    field || (field = this.field);\n    bool = bool && ((field.length > 1) || (tag && (tag.length > 1)));\n\n    const promises = !_resolve && (this.worker || this.async) && [];\n\n    // TODO solve this in one loop below\n    for (let i = 0, res, key, len; i < field.length; i++) {\n      let opt;\n\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key['field'];\n      }\n\n      if (promises) {\n        promises[i] = this.index[key].searchAsync(query, limit, opt || options);\n\n        // just collect and continue\n        continue;\n      }\n      else if (_resolve) {\n        res = _resolve[i];\n      }\n      else {\n        // inherit options also when search? it is just for laziness, Object.assign() has a cost\n        res = this.index[key].search(query, limit, opt || options);\n      }\n\n      len = res && res.length;\n\n      if (tag && len) {\n        const arr = [];\n        let count = 0;\n\n        if (bool) {\n          // prepare for intersection\n          arr[0] = [res];\n        }\n\n        for (let y = 0, key, res; y < tag.length; y++) {\n          key = tag[y];\n          res = this.tagindex[key];\n          len = res && res.length;\n\n          if (len) {\n            count++;\n            arr[arr.length] = bool ? [res] : res;\n          }\n        }\n\n        if (count) {\n          if (bool) {\n            res = intersect(arr, limit || 100, offset || 0);\n          }\n          else {\n            res = intersect_union(res, arr);\n          }\n\n          len = res.length;\n        }\n      }\n\n      if (len) {\n        result_field[count] = key;\n        result[count++] = res;\n      }\n      else if (bool) {\n        return [];\n      }\n    }\n\n    if (promises) {\n      const self = this;\n\n      // anyone knows a better workaround of optionally having async promises?\n      // the promise.all() needs to be wrapped into additional promise,\n      // otherwise the recursive callback wouldn't run before return\n      return new Promise(function (resolve) {\n        Promise.all(promises).then(function (result) {\n          resolve(self.search(query, limit, options, result));\n        });\n      });\n    }\n\n    if (!count) {\n      // fast path \"not found\"\n      return [];\n    }\n\n    if (pluck && (!enrich || !this.store)) {\n      // fast path optimization\n      return result[0];\n    }\n\n    for (let i = 0, res; i < result_field.length; i++) {\n      res = result[i];\n\n      if (res.length) {\n        if (enrich) {\n          res = apply_enrich.call(this, res);\n        }\n      }\n\n      if (pluck) {\n        return res;\n      }\n\n      result[i] = {\n        'field': result_field[i],\n        'result': res\n      };\n    }\n\n    return result;\n  }\n  contain(id) {\n    return !!this.register[id];\n  }\n  get(id) {\n    return this.store[id];\n  }\n  set(id, data) {\n    this.store[id] = data;\n    return this;\n  }\n\n  /**\n   * Serialize `this` into an exportable object\n   */\n  serialize() {\n    const result = {\n      tag:   this.tagIndex,\n      reg:   this.register,\n      store: this.store,\n      field: this.field,\n      index: {}\n    };\n    Object.entries(this.index).forEach(([key, index]) => {\n      result.index[key] = index.serialize();\n    });\n    return result;\n  }\n\n  /**\n   * Create a `Document` from a serialized object\n   */\n  static deserialize(obj, params) {\n    // TODO add properties here?\n    const result = new Document(params);\n    result.tagIndex = obj.tag;\n    result.register = obj.reg;\n    result.store    = obj.store;\n    result.field    = obj.field;\n    Object.entries(obj.index).forEach(([key, exportedIndex]) => {\n      result.index[key] = Index.deserialize(exportedIndex);\n      result.index[key].register = obj.reg;\n    });\n    return result;\n  }\n\n  // Helper methods\n\n  parse_descriptor(options, document) {\n    const index = create_object();\n    let field = document['index'] || document['field'] || document;\n\n    if (is_string(field)) {\n      field = [field];\n    }\n\n    for (let i = 0, key, opt; i < field.length; i++) {\n      key = field[i];\n\n      if (!is_string(key)) {\n        opt = key;\n        key = key['field'];\n      }\n\n      opt = is_object(opt) ? Object.assign({}, options, opt) : options;\n\n      if (!this.worker) {\n        index[key] = new Index(opt, this.register);\n      }\n\n      this.tree[i] = parse_tree(key, this.marker);\n      this.field[i] = key;\n    }\n\n    if (this.storetree) {\n      let store = document['store'];\n\n      if (is_string(store)) {\n        store = [store];\n      }\n\n      for (let i = 0; i < store.length; i++) {\n        this.storetree[i] = parse_tree(store[i], this.marker);\n      }\n    }\n\n    return index;\n  }\n}\n\nfunction parse_tree(key, marker){\n  const tree = key.split(':');\n  let count = 0;\n\n  for(let i = 0; i < tree.length; i++){\n    key = tree[i];\n\n    if(key.indexOf('[]') >= 0){\n      key = key.substring(0, key.length - 2);\n\n      if(key){\n        marker[count] = true;\n      }\n    }\n\n    if(key){\n      tree[count++] = key;\n    }\n  }\n\n  if(count < tree.length){\n    tree.length = count;\n  }\n\n  return count > 1 ? tree : tree[0];\n}\n\nfunction parse_simple(obj, tree){\n  if(is_string(tree)){\n    obj = obj[tree];\n  }\n  else{\n    for(let i = 0; obj && (i < tree.length); i++){\n      obj = obj[tree[i]];\n    }\n  }\n\n  return obj;\n}\n\nfunction store_value(obj, store, tree, pos, key){\n  obj = obj[key];\n\n  // reached target field\n\n  if(pos === (tree.length - 1)){\n    // store target value\n\n    store[key] = obj;\n  }\n  else if(obj){\n    if(is_array(obj)){\n      store = store[key] = new Array(obj.length);\n\n      for(let i = 0; i < obj.length; i++){\n        // do not increase pos (an array is not a field)\n        store_value(obj, store, tree, pos, i);\n      }\n    }\n    else{\n      store = store[key] || (store[key] = create_object());\n      key = tree[++pos];\n\n      store_value(obj, store, tree, pos, key);\n    }\n  }\n}\n\nfunction add_index(obj, tree, marker, pos, index, id, key, _append){\n  obj = obj[key];\n\n  if(obj){\n    // reached target field\n\n    if(pos === (tree.length - 1)){\n      // handle target value\n\n      if(is_array(obj)){\n        // append array contents so each entry gets a new scoring context\n\n        if(marker[pos]){\n          for(let i = 0; i < obj.length; i++){\n            index.add(id, obj[i], /* append: */ true, /* skip update: */ true);\n          }\n\n          return;\n        }\n\n        // or join array contents and use one scoring context\n\n        obj = obj.join(' ');\n      }\n\n      index.add(id, obj, _append, /* skip_update: */ true);\n    }\n    else{\n      if(is_array(obj)){\n        for(let i = 0; i < obj.length; i++){\n          // do not increase index, an array is not a field\n\n          add_index(obj, tree, marker, pos, index, id, i, _append);\n        }\n      }\n      else{\n        key = tree[++pos];\n\n        add_index(obj, tree, marker, pos, index, id, key, _append);\n      }\n    }\n  }\n}\n\n\n\n\n\n\n/**\n * @this Document\n */\n\nfunction get_tag(key, limit, offset, enrich){\n  let res = this.tagindex[key];\n  let len = res && (res.length - offset);\n\n  if(len && (len > 0)){\n    if((len > limit) || offset){\n      res = res.slice(offset, offset + limit);\n    }\n\n    if(enrich){\n      res = apply_enrich.call(this, res);\n    }\n\n    return {\n\n      'tag': key,\n      'result': res\n    };\n  }\n}\n\n/**\n * @this Document\n */\n\nfunction apply_enrich(res){\n  const arr = new Array(res.length);\n\n  for(let x = 0, id; x < res.length; x++){\n    id = res[x];\n\n    arr[x] = {\n\n      'id': id,\n      'doc': this.store[id]\n    };\n  }\n\n  return arr;\n}\n\n// TODO move all of this into this file\nDocument.prototype.searchCache = searchCache;\napply_async(Document.prototype);\n"],"names":["parse_option","value","default_value","create_object_array","count","array","Array","i","create_object","Object","create","sort_by_length_down","a","b","length","is_array","val","constructor","is_string","is_object","is_function","pipeline","str","normalize","split","_collapse","replace","this","matcher","stemmer","string","final","prev","char","len","collapse","words","filter","map","filtered","word","regex_whitespace","init_stemmer_or_matcher","obj","is_stemmer","keys","get_keys","removal","key","tmp","regex","regexp","RegExp","encode","call","toLowerCase","global_lang","global_charset","prototype","register","self","args","arg","callback","promise","Promise","resolve","setTimeout","async","res","apply","then","intersect","arrays","limit","offset","suggest","check","check_suggest","result","size","x","word_arr","word_arr_len","check_new","found","y","arr","arr_len","check_idx","id","z","intersect_union","mandatory","union","CacheClass","cache","queue","searchCache","query","options","get","search","set","pos","indexOf","del","item","splice","preset","memory","charset","resolution","minlength","fastupdate","performance","optimize","context","depth","match","tokenize","score","default","Index","_register","lang","console","warn","assign","apply_preset","default_encoder","bidirectional","boost","resolution_ctx","ctx","rtl","init_filter","Cache","append","content","add","_append","_skip_update","update","dupes_ctx","dupes","term","term_length","get_score","token","partial_score","substring","push_index","Math","min","dupes_inner","keyword","context_score","swap","query_new","index","sort","add_result","single_result","single_term","get_array","slice","contain","remove","_skip_deletion","refs","remove_index","serialize","reg","opt","deserialize","params","concat","apply_async","Document","document","tree","field","marker","parse_tree","storetree","store","tag","tagindex","worker","parse_descriptor","parse_simple","add_index","store_value","_resolve","pluck","enrich","bool","result_field","get_tag","promises","searchAsync","all","apply_enrich","data","tagIndex","entries","forEach","exportedIndex","join","doc"],"mappings":"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"}